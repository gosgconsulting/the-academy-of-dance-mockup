---
alwaysApply: false
---
Puck’s core behaviour is configured via the Config. This describes:

which components are available to Puck
how to render each component
which fields to show when the user selects a component
additional information, like category grouping
The Config is provided via the config prop to the main Puck components:

<Puck> reads the Config and renders an editor UI. The user interacts with the editor to produce a data payload.
<Render> takes a data payload and renders it according to the provided Config.
The render function
Components can be defined via the components object in Config. Every definition must provide a render function:


const config = {
  components: {
    HeadingBlock: {
      render: () => {
        return <h1>Hello, world</h1>;
      },
    },
  },
};
This tells Puck that HeadingBlock is a valid component, and describes how to render it.

When the user drags the component onto the preview and hits Publish in the editor UI via the <Puck> component, this Config will produce a data payload like this:


{
  "content": [
    {
      "type": "HeadingBlock",
      "props": {
        "id": "HeadingBlock-1234"
      }
    }
  ],
  "root": {}
}
The data payload and Config together tell <Render> how to render the page. It can also be provided to <Puck> as an initial data payload.

Interactive Demo
Try interacting with the heading
TypeScript
If you’re using TypeScript, we recommend strictly typing your config:


import type { Config } from "@measured/puck";
 
type Components = {
  HeadingBlock: {};
};
 
const config: Config<Components> = {
  components: {
    HeadingBlock: {
      render: () => {
        return <h1>Hello, world</h1>;
      },
    },
  },
};
Adding fields
Fields allow users to provide input to components. The value of each field is passed in as a prop to the render function.

You can define a field via the fields parameter:


const config = {
  components: {
    HeadingBlock: {
      fields: {
        title: {
          type: "text",
        },
      },
      render: ({ title }) => {
        return <h1>{title}</h1>;
      },
    },
  },
};
This will render a Text field when the user selects an instance of the HeadingBlock component in the editor UI.

Interactive Demo
Text field example
title
Show output
When the user modifies the input, the editor will produce a data payload like this:


{
  "content": [
    {
      "type": "HeadingBlock",
      "props": {
        "id": "HeadingBlock-1234",
        "title": "Hello, world"
      }
    }
  ],
  "root": {}
}
TypeScript
It’s best to define the props for the component if using TypeScript. This enables strict type checking for your fields.


import type { Config } from "@measured/puck";
 
type Components = {
  HeadingBlock: {
    title: string;
  };
};
 
const config: Config<Components> = {
  // ...
};
Setting default props
Default props allow you to set an initial value for a prop when a new component is added.

Provide an object to the defaultProps parameter to configure this:


const config = {
  components: {
    HeadingBlock: {
      fields: {
        title: {
          type: "text",
        },
      },
      defaultProps: {
        title: "Hello, world",
      },
      render: ({ title }) => {
        return <h1>{title}</h1>;
      },
    },
  },
};
Unlike default parameters, defaultProps are stored in the data payload and will populate the Puck fields.

Interactive Demo
Text field example
title
Hello, world
Hello, world
Show output

Root Configuration
The root is the top-level component within Puck. It:

Renders a single wrapper around your other components. This can be overwritten with a render function.
Stores meta data, like the page title. This can be extended with fields.
Configuring the root is similar to configuring components.

The root render function
Use the root parameter to specify a render function:


const config = {
  components: {
    HeadingBlock: {
      render: () => {
        return <h1>Hello, world</h1>;
      },
    },
  },
  root: {
    render: ({ children }) => {
      return <div>{children}</div>;
    },
  },
};
The root render function will wrap all of the components. children is a node containing the nested components.

If you don’t render children, your components will not be rendered unless you define another slot.

Example output
Given a minimal data payload containing one HeadingBlock


{
  "content": [
    {
      "type": "HeadingBlock",
      "props": {
        "id": "HeadingBlock-1234"
      }
    }
  ],
  "root": {}
}
the example config will render HTML nodes like this:

<!-- root render -->
<div>
  <!-- HeadingBlock render -->
  <h1>Hello, world</h1>
 
  <!-- Remaining nodes -->
</div>
Adding fields
Root fields provide user input to the root render method, and can be used to store metadata.

By default, root is configured with a title text field:


const config = {
  // ...
  root: {
    render: ({ children, title }) => {
      return (
        <div>
          <h1>{title}</h1>
          {children}
        </div>
      );
    },
  },
};
You can override the default field configuration by providing custom Fields to the fields parameter:


const config = {
  // ...
  root: {
    fields: {
      title: { type: "text" }, // You need to redefine the `title` field if we want to retain it
      description: { type: "textarea" },
    },
    render: ({ children, title, description }) => {
      return (
        <div>
          <h1>{title}</h1>
          <p>{description}</p>
          {children}
        </div>
      );
    },
  },
};
When the user modifies the inputs, the editor will produce a data payload like this:


{
  "content": [
    // ...
  ],
  "root": {
    "props": {
      "title": "Hello, world",
      "description": "Lorem ipsum"
    }
  }
}
TypeScript
Generic types can be passed to the Config type to strictly type your root configuration:


import type { Config } from "@measured/puck";
 
type RootProps = {
  description: string;
};
 
const config: Config<{}, RootProps> = {
  // ...
};
Setting default props
Provide an object to the defaultProps parameter to configure default props for the root fields:


const config = {
  // ...
  root: {
    fields: {
      title: { type: "text" },
      description: { type: "textarea" },
    },
    defaultProps: {
      title: "Hello, world",
      description: "Lorem ipsum",
    },
    render: ({ children, title, description }) => {
      return (
        <div>
          <h1>{title}</h1>
          <p>{description}</p>
          {children}
        </div>
      );
    },
  },
};
Unlike default parameters, defaultProps are stored in the data payload and will populate the Puck fields.

Multi-column Layouts
Puck supports nested and multi-column layouts across any CSS layout using the slot field.

Slots replace the <DropZone> component component, which will soon be deprecated and removed. For migration notes, see these docs.
Nested components
Add the slot field to your component to create a zone that you can drop components into.


const config = {
  components: {
    Example: {
      fields: {
        content: {
          type: "slot",
        },
      },
      render: ({ content: Content }) => {
        return <Content />;
      },
    },
    Card: {
      render: () => <div>Hello, world</div>,
    },
  },
};
Interactive Demo
Nested components example
Fixed layouts
Combine multiple DropZones to achieve fixed layouts. By default, components inside a DropZone are arranged along the vertical (block) axis.


const config = {
  components: {
    Example: {
      fields: {
        leftColumn: {
          type: "slot",
        },
        rightColumn: {
          type: "slot",
        },
      },
      render: ({ leftColumn: LeftColumn, rightColumn: RightColumn }) => {
        return (
          <div
            style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }}
          >
            <LeftColumn />
            <RightColumn />
          </div>
        );
      },
    },
    Card: {
      render: ({ text }) => <div>{text}</div>,
    },
  },
};
Interactive Demo
Fixed layout example
Fluid layouts
Apply the CSS display property to a slot via the style or className props to arrange your components in different layouts. Puck supports drag-and-drop for all display values, including grid and flex.


const config = {
  components: {
    Example: {
      fields: {
        content: {
          type: "slot",
        },
      },
      render: ({ content: Content }) => (
        <Content
          style={{
            // Use CSS grid in this slot
            display: "grid",
            gridTemplateColumns: "2fr 1fr",
            gap: 16,
          }}
        />
      ),
    },
    Card: {
      render: ({ text }) => <div>{text}</div>,
    },
  },
};
Interactive Demo
Fluid layout using CSS grid
Removing the wrapper
By default, Puck will wrap your components in a div element. For some layouts, you may need to eliminate the wrapping element and treat the child component as a direct descendant of its’ parent slot.

For example, this is required if you wish to use CSS rules like flex-grow, grid-column, or grid-row.

Use the inline component parameter to remove the wrapping element. When using this API, you must also specify which element is draggable by passing the puck.dragRef prop to your element’s ref prop.


const config = {
  components: {
    Example: {
      fields: {
        content: {
          type: "slot",
        },
      },
      render: ({ content: Content }) => (
        <Content
          style={{
            display: "grid",
            gridTemplateColumns: "1fr 1fr 1fr 1fr",
            gridTemplateRows: "1fr 1fr 1fr 1fr",
            gap: 16,
          }}
        />
      ),
    },
    Card: {
      inline: true, // Enable inline mode, removing the Puck wrapper
      render: ({ text, spanCol, spanRow, puck }) => (
        <div
          ref={puck.dragRef} // Let Puck know this element is draggable
          style={{
            gridColumn: `span ${spanCol}`,
            gridRow: `span ${spanRow}`,
          }}
        >
          {text}
        </div>
      ),
    },
  },
};
Interactive Demo
Advanced grid example
Restricting components
Use the allow and disallow parameters to restrict which components can be dragged into a slot.


const config = {
  components: {
    fields: {
      content: {
        type: "slot",
        allow: ["Card"],
      },
    },
    Example: {
      render: ({ content: Content }) => {
        return <Content />;
      },
    },
  },
};
Combine this with categories to restrict behavior based on your existing groups.


const config = {
  categories: {
    typography: {
      components: ["Card"],
    },
  },
  components: {
    Example: {
      fields: {
        content: {
          type: "slot",
          allow: categories.typography.components,
        },
      },
      render: ({ content: Content }) => {
        return <Content />;
      },
    },
  },
};
Alternatively, you can provide allow and disallow to your render function.

Setting default props
Use slots with defaultProps to pre-populate it when the component is inserted with an array of ComponentData.


const config = {
  components: {
    Example: {
      fields: {
        content: {
          type: "slot",
        },
      },
      defaultProps: {
        content: [
          {
            type: "Card",
            props: {
              text: "Pre-populated",
            },
          },
        ],
      },
      render: ({ content: Content }) => <Content />,
    },
    Card: {
      render: ({ text }) => <div>{text}</div>,
    },
  },
};
Interactive Demo
Fluid layout using CSS grid

Categories
Categories allow you to group components in the left side bar.

Creating categories
Use the categories API to define the component categories.


const config = {
  categories: {
    typography: {
      components: ["HeadingBlock", "ParagraphBlock"],
    },
  },
  // ...
};
Components can appear in separate categories:


const config = {
  categories: {
    typography: {
      components: ["HeadingBlock", "ParagraphBlock"],
    },
    foundational: {
      components: ["HeadingBlock"],
    },
  },
  // ...
};
You can also change the title, collapse and hide categories:


const config = {
  categories: {
    typography: {
      components: ["HeadingBlock", "ParagraphBlock"],
      title: "Text",
      defaultExpanded: false, // Collapse this category by default
    },
    foundational: {
      components: ["HeadingBlock"],
      visible: false, // Mark this category as hidden
    },
  },
  // ...
};
The “other” category
Any uncategorized components will be grouped in the other category. This will be visible by default. It respects the same API as other categories.


const config = {
  categories: {
    typography: {
      components: ["HeadingBlock", "ParagraphBlock"],
    },
    other: {
      title: "Other components",
    },
  },
  // ...
};
TypeScript
You can pass in available category names to the Config type if using TypeScript


import type { Config } from "@measured/puck";
 
const config: Config<{}, {}, "typography" | "interactive"> = {
  categories: {
    typography: {},
    interactive: {},
  },
  // ...
};

Dynamic Props
Dynamic prop resolution allows you to change the props for a component after the props have been changed by the user. This is useful for making third-party API calls, such as requesting the latest content from a headless CMS.

Dynamic component props
The resolveData function allows you to make changes to the props and set fields as read-only.

For example, we can set the value of one prop to another:


const config = {
  components: {
    HeadingBlock: {
      fields: {
        title: {
          type: "text",
        },
        resolvedTitle: {
          type: "text",
        },
      },
      resolveData: async ({ props }) => {
        return {
          props: {
            resolvedTitle: props.title,
          },
        };
      },
      render: ({ resolvedTitle }) => {
        return <h1>{resolvedTitle}</h1>;
      },
    },
  },
};
Interactive Demo
Try changing the "title" field
title
Hello, world
resolvedTitle
Show output
When inserting components with resolveData, the Puck state will update twice - once for the initial insert, and once more when the method resolves, if it changes the data. This will be reflected in the undo/redo history.

Setting fields as read-only
resolveData also allows us to mark fields as read-only using the readOnly parameter.


const config = {
  components: {
    HeadingBlock: {
      // ...
      resolveData: async ({ props }) => {
        return {
          props: {
            resolvedTitle: props.title,
          },
          readOnly: { resolvedTitle: true },
        };
      },
      // ...
    },
  },
};
Interactive Demo
The resolvedTitle field is locked
title
Hello, world
resolvedTitle
Show output
Preventing duplicate calls
It’s possible that resolveData may carry out an expensive operation (like an API call) that we want to avoid making unless a specific prop has changed.

This can be restricted by checking the changed param before calling any expensive operations.


const config = {
  components: {
    HeadingBlock: {
      // ...
      resolveData: async ({ props }, { changed }) => {
        if (!changed.text) return { props };
 
        return {
          props: {
            resolvedTitle: await expensiveOperation(props.title),
          },
        };
      },
      // ...
    },
  },
};
Dynamic Root props
The resolveData method is also available on the root component.


const config = {
  components: {},
  root: {
    fields: {
      title: {
        type: "text",
      },
      resolvedTitle: {
        type: "text",
      },
    },
    resolveData: async ({ props }) => {
      return {
        props: {
          resolvedTitle: props.title,
        },
      };
    },
    render: ({ children, resolvedTitle }) => {
      return (
        <>
          <h1>{resolvedTitle}</h1>
          {children}
        </>
      );
    },
  },
};
Triggering resolveData
Resolve data is triggered whenever the props for a component change, or when the resolveAllData utility is used.

import { resolveAllData } from "@measured/puck";
 
const updatedData = await resolveAllData(data, config);

Dynamic Fields
Dynamic field resolution allows you to change the field configuration for a component based on the current component props.

Dynamic component fields
The resolveFields function allows you to make synchronous and asynchronous changes to the field configuration.

For example, we can set the configuration of one field based on the prop value of another:


const config = {
  components: {
    MyComponent: {
      resolveFields: (data) => {
        const fields = {
          drink: {
            type: "radio",
            options: [
              { label: "Water", value: "water" },
              { label: "Orange juice", value: "orange-juice" },
            ],
          },
        };
 
        if (data.props.drink === "water") {
          return {
            ...fields,
            waterType: {
              // ... Define field
            },
          };
        }
 
        return fields;
      },
      // ...
    },
  },
};
Interactive Demo
Try changing the "drink" field
drink

Water

Orange juice
waterType

Still

Sparkling
water (still)

Show output
Making asynchronous calls
The resolveFields function also enables asynchronous calls.

Here’s an example populating the options for a select field based on a radio field


const config = {
  components: {
    MyComponent: {
      resolveFields: async (data, { changed, lastFields }) => {
        // Don't call the API unless `category` has changed
        if (!changed.category) return lastFields;
 
        // Make an asynchronous API call to get the options
        const options = await getOptions(data.category);
 
        return {
          category: {
            type: "radio",
            options: [
              { label: "Fruit", value: "fruit" },
              { label: "Vegetables", value: "vegetables" },
            ],
          },
          item: {
            type: "select",
            options,
          },
        };
      },
      render: ({ item }) => <h1>{item}</h1>,
    },
  },
};